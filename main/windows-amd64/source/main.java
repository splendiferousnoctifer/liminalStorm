/* autogenerated by Processing revision 1286 on 2023-01-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;
import java.lang.*;
import java.lang.reflect.*;
import processing.core.*;
import TUIO.*;
import java.util.*;
import processing.sound.*;
import processing.sound.SoundFile;
import java.awt.Point;
import processing.core.PVector;
import java.time.Duration;
import java.util.Random;
import java.util.Arrays;
import java.util.List;
import java.util.Collections;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {



boolean debug = true;
boolean osCompatible;
String operatingSystem = System.getProperty("os.name");


float cursor_size = 25;
PFont font;

public int scaleFactor = 4;
public int windowWidth = 3840/scaleFactor;
public int windowHeight = 2160*2/scaleFactor;
public int wallHeight = windowHeight/2;
public boolean bFullscreen = false;

public int hFloor;
public int wallThird;

boolean ShowTrack = true;
boolean ShowPath = true;
boolean ShowFeet = true;
int amount = 5;


int GRASS;
int RAIN;
int LEAVES;
int SNOW;
int STORM;
int END;

int[] splitDurations, splitOrder;
int entireDuration;

StateMgr stateMgr;
TimeSplit timeSplit;

 public void settings()
{
  if (bFullscreen)
  {
    fullScreen(P2D, SPAN);
  }
  else
  {
    size(windowWidth, windowHeight);   
  }
}

 public void setup() {
  loadImages();
  //load();
  switch (operatingSystem) {
    case "Windows":
      osCompatible = true;     
      break;
    case "Mac":
      osCompatible = false;
      break;
    default:
      osCompatible = true;
      break;
  }
  
  // update with actual fullscreen resolutions
  if (bFullscreen)
  {  
    windowWidth = width;
    windowHeight = height;
    wallHeight = windowHeight / 2;  
  }  
  
  frameRate(60);
  
  noStroke();
  fill(0);
  
  wallThird = abs(wallHeight/3); //absolute value for third of wall
  hFloor = wallThird * 2; //two thirds for start of floor extension
  
  
  colorMode(RGB, 255,255,255,255);
  timeSplit = new TimeSplit();
  stateMgr = new StateMgr();

  noStroke();
  
  if (debug){
    splitDurations = new int[] {30000,30000,30000,30000};
    splitOrder = new int[] {1,3,2};
  } else {
    splitDurations = timeSplit.splitInterval();
    splitOrder = timeSplit.assignNumbers(splitDurations);
  }
  
  
  GRASS = stateMgr.addState(new Grass(stateMgr, splitDurations[0]));

  stateOrder(splitOrder, splitDurations);
  
  END = stateMgr.addState(new End(stateMgr, 10000));
  
  stateMgr.setState(GRASS);  
  
  entireDuration = 0;
  for (int num : splitDurations) {entireDuration += num;}
  
  println("Time Intervals: ", Arrays.toString(splitDurations));
  println("Order of Intervals: ", Arrays.toString(splitOrder));
  println("Setup Done! \n");
  
}

 public void draw() {
  stateMgr.getCurrentState().draw();
  stateMgr.updateStates();
  
  int currentID = stateMgr.getCurrentStateID();
  
  if ( currentID == splitDurations.length) {
    stateMgr.setState(END);
  } else if (stateMgr.getTimeInState() > splitDurations[currentID] && currentID < splitDurations.length){
    stateMgr.setState(stateMgr.nextStateID(currentID));
  } 
  
  int currentState = (currentID == 0 || currentID > 4) ? 0 : splitOrder[currentID-1];
    
  switch (currentState) {
      case 0: //grass
        drawSpringPath(fl1);
        break;
      case 1: //rain
        drawRainPath(img3);
        break;
      case 2: //leaves
        drawPath(img2);
        break;
      case 3: //snow
        drawWinterPath(w1);
        break;
      case 4: //storm
        break;
   }

  //ToDo: Audio system
  /*
  while(millis() <= entireDuration){
    // intervals for audio file switching
    if(millis()%interval == 0){
       // loading takes some time, chooses new file about every 10 - 15 seconds
      sound.play(); // iterates through files of array
      break;
    }  
  }*/
  
  
}

 public void stateOrder(int[] order, int[] durations) {
    for (int i = 0; i < order.length; i++) {
      switch (order[i]) {
        case 1:
          RAIN = stateMgr.addState(new Rain(stateMgr, durations[i+1]));
          break;
        case 2:
          LEAVES = stateMgr.addState(new Leaves(stateMgr, durations[i+1]));
          break;
        case 3:
          SNOW = stateMgr.addState(new Snow(stateMgr, durations[i+1]));
          break;
        case 4: 
          STORM = stateMgr.addState(new Storm(stateMgr, durations[i+1]));
          break;
      }
    }
}

 public void keyPressed()
{
  switch(key)
  {
  case 'p':
    ShowPath = !ShowPath;
    break;
  case 't':
    ShowTrack = !ShowTrack;
    break;
  case 'f':
    ShowFeet = !ShowFeet;
    break;
  }
}

 public void loadImages(){
  font = createFont("Arial", 18);
  textFont(font, 18);
  textAlign(CENTER, CENTER);



  initPlayerTracking();
  ShowTrack = true;
  ShowPath = false; // always shows path of players in tracking
  ShowFeet = true; // always shows feet of players in tracking
  //imageMode(CENTER);
  
  image = loadImage(imgPath);
  image.resize(0, screen_cursor);

  img2 = loadImage(path2);
  //img2.resize(0,screen_cursor);
   
   
   
  img3 = loadImage(path3);
  img3.resize(0,screen_cursor);
  
  fl1 = loadImage(f1);
  file = new SoundFile(this, soundPath);
  
  w1 = loadImage(winterImg);
  w1.resize(0,screen_cursor);
  winter = new SoundFile(this, wPath);
}

 public void load(){
  sound = new SoundFile(this, chooseAudioFile(audioFiles));
}
  
 public String chooseAudioFile(String[] files){
  int r =PApplet.parseInt(random(files.length));
  return files[r];
}
PImage image;
String imgPath = "images/FootLeaves.png"; // one footprint

PImage img2;
String path2 = "images/FeetLeaves_small.png"; // 2 footprints
PImage img3;
String path3 = "images/Umbrella.png"; // 2 footprints


// Grass flower graphics
String f1 = "images/flowers/flower1.png";
String f2 = "images/flowers/flower2.png";
String f3 = "images/flowers/flower3.png";
String f4 = "images/flowers/flower4.png";
String f5 = "images/flowers/flower5.png";

PImage fl1;
PImage fl2;
PImage fl3;
PImage fl4;
PImage fl5;

PImage[] flowers = {fl1,fl2,fl3,fl4,fl5};


//winter path

PImage w1;
String winterImg = "images/FeetSnow.png";


SoundFile winter;
String wPath = "sound/snowCrunch_single.mp3";

int screen_cursor = 25;

SoundFile file;
SoundFile sound;
SoundFile sound2;

String soundPath = "sound/leaves_crunching.mp3";//"sound/rain_drops_little_thunder.mp3";

String s1 = "sound/snowCrunch_single.mp3";
String s2 = "sound/grass_walking.wav";
String s3 = "sound/leaves_crunching.mp3";
String s4 = "sound/rain_drops_little_thunder.mp3";
String s5= "sound/rain_thunder.mp3";
class StateMgr {
 
  BaseState[] states;
  
  int currentStateID;
  int stateStamp;
  
   public int setState(int newState) {
    if (newState < 0 || newState >= states.length) {
      return -1;
    }
  
    if (newState != currentStateID) {
      currentStateID = newState;
      stateStamp = millis();
      println("switch to state " + currentStateID);
    }
    
    return currentStateID;
  }
  
   public BaseState getCurrentState() {
    return getState(currentStateID);
  }

   public int getCurrentStateID() {
    return currentStateID;
  }
  
   public BaseState getState(int stateID) {
   if (stateID < 0 || stateID >= states.length)
      return null;
    
    return states[stateID]; 
  }
  
   public int getTimeInState() {
    return millis() - stateStamp;
  }
  
   public int addState(BaseState state) {
    if (states == null) {
      println("creating new states array");
      states = new BaseState[1];
      states[0] = state;
    } else {
      states = (BaseState[])append(states, state);
    }
    
    state.setID(states.length - 1);
    state.setup();
      
    //println("state " + state.getID() + " added");
    
    return state.getID();
  } 
  
   public int updateStates() {
    // query current state for next state id
    return setState(getCurrentState().getNextStateID());
  }
  
   public void amountStates() {
    println(states.length);
  }
  
   public int nextStateID(int currentID) {
    if (currentID < states.length) {
      return currentStateID + 1;
    }
          print("hi");

    return states.length;
  }

  
}

// Version 3.1
// this class replaces former TUIOHelper in this new and enhanced implementation
// do not change anything in here unless you are really sure of what you are doing







// reference: https://github.com/processing/processing/wiki/Library-Basics
public class PharusClient extends PApplet 
{
  // internal stuff only
  PApplet parent;
  TuioProcessing tuioProcessing;
  int nextUniqueID = 0;
  Method playerAddEventMethod;
  Method playerRemoveEventMethod;
  int wallHeight = 0;

  boolean doDebug = false;  
  int maxAge = 50; // age is measured in update cycles, with 25 fps this is 2 seconds
  float jumpDistanceMaxTolerance = 0.05f; // max distance allowed when jumping between last known position and potential landing position, unit is in pixels relative to window width
  HashMap<Long, Player> players = new HashMap<Long, Player>();

  PharusClient(PApplet _parent, int _wallHeight) 
  {
    this.parent = _parent;
    this.wallHeight = _wallHeight;
    // this is a bit of a hack but need for TuioProcessing to work properly
    width = parent.width;
    height = parent.height;
    tuioProcessing = new TuioProcessing(this); 

    parent.registerMethod("dispose", this);
    parent.registerMethod("pre", this); 

    // check to see if the host applet implements event functions
    try 
    {
      playerAddEventMethod = parent.getClass().getMethod("pharusPlayerAdded", new Class[] { Player.class });
    } 
    catch (Exception e) 
    {
      // no such method, or an error..
      println("Function pharusPlayerAdded() not found, Player add events disabled.");
    }
    try 
    {
      playerRemoveEventMethod = parent.getClass().getMethod("pharusPlayerRemoved", new Class[] { Player.class });
    } 
    catch (Exception e) 
    {
      // no such method, or an error..
      println("Function pharusPlayerRemoved() not found, Player remove events disabled.");
    }    
  }
  
  // age is measured in update cycles, with 25 fps this is 2 seconds
  public void setMaxAge(int age)
  {
    maxAge = age;
  }

  // max distance allowed when jumping between last known position and potential landing position, unit is in pixels relative to window width
  public void setjumpDistanceMaxTolerance(float relDist)
  {
    jumpDistanceMaxTolerance = relDist;
  }

   public void firePlayerAddEvent(Player player) 
  {
    if (playerAddEventMethod != null) 
    {
      try 
      {
        playerAddEventMethod.invoke(parent, new Object[] { player });
      } 
      catch (Exception e) 
      {
        System.err.println("Disabling event for " + playerAddEventMethod.getName() + " because of an error.");
        e.printStackTrace();
        playerAddEventMethod = null;
      }
    }
  }
  
   public void firePlayerRemoveEvent(Player player) 
  {
    if (playerRemoveEventMethod != null) 
    {
      try 
      {
        playerRemoveEventMethod.invoke(parent, new Object[] { player });
      } 
      catch (Exception e) 
      {
        System.err.println("Disabling event for " + playerRemoveEventMethod.getName() + " because of an error.");
        e.printStackTrace();
        playerRemoveEventMethod = null;
      }
    }
  }

  public void dispose() 
  {
    // Anything in here will be called automatically when the parent sketch shuts down.
    players.clear();
    tuioProcessing.dispose();
  }

  public void pre() 
  {
    // Method that's called just after beginDraw(), meaning that it can affect drawing.

    int m = millis();

    // Increase age of all players, remove those too old
    Iterator<HashMap.Entry<Long, Player>> iter = players.entrySet().iterator();
    while (iter.hasNext()) 
    {
      HashMap.Entry<Long, Player> playersEntry = iter.next();
      Player p = (Player)playersEntry.getValue();
      p.feet.clear();  
      p.age++;
      // remove if too old
      if (p.age > maxAge)
      {
          firePlayerRemoveEvent(p);
          iter.remove();
      }
    }
    
    // Update known players with available tuio data
    ArrayList<TuioCursor> tcl = tuioProcessing.getTuioCursorList();
    int i = 0;
    while (i < tcl.size())
    {
      TuioCursor tc = tcl.get(i);
      Player p = players.get(tc.getSessionID());
      if (p != null)
      {
        // update player
        p.age = 0;
        p.x = tc.getScreenX(width);
        p.y = tc.getScreenY(height - wallHeight) + wallHeight;
        tcl.remove(i);
      }
      else
      {
        i++;
      }
    }

    // check if there are new players left and handle them accordingly 
    if (tcl.size() > 0)
    {
      for (TuioCursor tc : tcl)
      {
        boolean found = false;
        // check if this was a previously known player with different id (TUIO id swap case due to jumping e.g.)
        for (HashMap.Entry<Long, Player> playersEntry : players.entrySet()) 
        {
          Player p = playersEntry.getValue();
          if (p.age == 0)
          {
            continue;
          }
          if (dist(p.x, p.y, tc.getScreenX(width), tc.getScreenY(height - wallHeight) + wallHeight) < jumpDistanceMaxTolerance * width)
          {
              // swap previous TUIO id to new id
              println("updating tuio id of player " + p.id + " from " + p.tuioId + " to " + tc.getSessionID());
              players.remove(p.tuioId);
              players.put(tc.getSessionID(), p);
              // update player
              p.age = 0;
              p.x = tc.getScreenX(width);
              p.y = tc.getScreenY(height - wallHeight) + wallHeight;
              found = true;
              break;
          }
        }
        // add as new player if nothing found
        if (!found)
        {
          Player p = new Player(this, nextUniqueID++, tc.getSessionID(), tc.getScreenX(width), tc.getScreenY(height - wallHeight) + wallHeight);
          players.put(tc.getSessionID(), p);
          firePlayerAddEvent(p);
        }
      }
    }
    
    // update the feet
    ArrayList<TuioObject> tuioObjectList = tuioProcessing.getTuioObjectList();
    ArrayList<TuioCursor> tuioCursorList = tuioProcessing.getTuioCursorList();
    for (TuioObject to : tuioObjectList)
    {
      Player p = null;
      if (to.getSymbolID() < tuioCursorList.size())
      {
        TuioCursor tc = tuioCursorList.get(to.getSymbolID());
        p = players.get(tc.getSessionID());
      }
      if (p != null)
      {
        p.feet.add(new Foot(to.getScreenX(width), to.getScreenY(height - wallHeight) + wallHeight));
      }
      else
      {
        println("unkown foot id: " + to.getSymbolID());
      } 
    }
    
  //  println((millis() - m) + " ms update");
  }

  // ------ these callback methods are called whenever a TUIO event occurs ------------------

  // called when an object is added to the scene
   public void addTuioObject(TuioObject tobj) 
  {
    if (doDebug)
      println("add object "+tobj.getSymbolID()+" ("+tobj.getSessionID()+") "+tobj.getX()+" "+tobj.getY()+" "+tobj.getAngle());
  }

  // called when an object is removed from the scene
   public void removeTuioObject(TuioObject tobj) 
  {
    if (doDebug)
      println("remove object "+tobj.getSymbolID()+" ("+tobj.getSessionID()+")");
  }

  // called when an object is moved
   public void updateTuioObject (TuioObject tobj) 
  {
    if (doDebug)
      println("update object "+tobj.getSymbolID()+" ("+tobj.getSessionID()+") "+tobj.getX()+" "+tobj.getY()+" "+tobj.getAngle()+" "+tobj.getMotionSpeed()+" "+tobj.getRotationSpeed()+" "+tobj.getMotionAccel()+" "+tobj.getRotationAccel());
  }

  // called when a cursor is added to the scene
   public void addTuioCursor(TuioCursor tcur) 
  {
    if (doDebug)
      println("add cursor "+tcur.getCursorID()+" ("+tcur.getSessionID()+ ") "+tcur.getX()+" "+tcur.getY());
  }

  // called when a cursor is moved
   public void updateTuioCursor (TuioCursor tcur) 
  {
    if (doDebug)
      println("update cursor "+tcur.getCursorID()+" ("+tcur.getSessionID()+ ") " +tcur.getX()+" "+tcur.getY()+" "+tcur.getMotionSpeed()+" "+tcur.getMotionAccel());
  }

  // called when a cursor is removed from the scene
   public void removeTuioCursor(TuioCursor tcur) 
  {
    if (doDebug)
      println("remove cursor "+tcur.getCursorID()+" ("+tcur.getSessionID()+")");
  }

  // called after each message bundle
  // representing the end of an image frame
   public void refresh(TuioTime bundleTime) 
  { 
    redraw();
  }

   public void addTuioBlob(TuioBlob tblb)
  {
    if (doDebug)
      println("add blob "+tblb.getBlobID()+" ("+tblb.getSessionID()+ ") "+tblb.getX()+" "+tblb.getY());
  }

   public void removeTuioBlob(TuioBlob tblb)
  {
    if (doDebug)
      println("remove blob "+tblb.getBlobID()+" ("+tblb.getSessionID()+ ") "+tblb.getX()+" "+tblb.getY());
  }

   public void updateTuioBlob(TuioBlob tblb)
  {
    if (doDebug)
      println("update blob "+tblb.getBlobID()+" ("+tblb.getSessionID()+ ") "+tblb.getX()+" "+tblb.getY());
  }
}

// Version 3.1
// this class contains all the information for one player and gets updated by the PharusClient
// extend this class with your player code if needed, but do not change the functions and variables that are there already as PharusClient depends on it

class Player
{
  public Player(PharusClient pc, int id, long tuioId, float x, float y)
  {
    this.pc = pc;
    this.id = id;
    this.tuioId = tuioId;
    this.x = x;
    this.y = y;
  }

  // --- All the information about a player ---
  PharusClient pc; // do not modify this, PharusClient updates it
  int id; // do not modify this, PharusClient updates it
  long tuioId; // do not modify this, PharusClient updates it
  int age; // do not modify this, PharusClient updates it
  float x; // do not modify this, PharusClient updates it
  float y; // do not modify this, PharusClient updates it
  ArrayList<Foot> feet = new ArrayList<Foot>(); // do not modify this, PharusClient updates it

  // TODO extend this with additional fields

  // --- Some functions that have information about the player ---
   public boolean isJumping()
  {
    // we assume that we jump if we have no feet and update
    return feet.size() == 0 && age > 1;
  }

  // handling of path information
   public int getNumPathPoints()
  {
    TuioCursor tc = pc.tuioProcessing.getTuioCursor(tuioId);
    if (tc != null)
    {
      return tc.getPath().size();
    }
    return -1;
  }
   public float getPathPointX(int pointID)
  {
    TuioCursor tc = pc.tuioProcessing.getTuioCursor(tuioId);
    if (tc != null)
    {
      ArrayList pointList = tc.getPath();
      if (pointList == null || pointList.size() <=  pointID)
      {
        return 0;
      }
      TuioPoint tp = (TuioPoint)pointList.get(pointID);
      return tp.getScreenX(width);
    }
    return 0;
  }
   public float getPathPointY(int pointID)
  {
    TuioCursor tc = pc.tuioProcessing.getTuioCursor(tuioId);
    if (tc != null)
    {
      ArrayList pointList = tc.getPath();
      if (pointList == null || pointList.size() <=  pointID)
      {
        return 0;
      }
      TuioPoint tp = (TuioPoint)pointList.get(pointID);
      return tp.getScreenY(height - pc.wallHeight) + pc.wallHeight;
    }
    return 0;
  }  

  // TODO extend this with additional functions

}

// helper class for feet
public class Foot
{
  public Foot(float x, float y)
  {
    this.x = x;
    this.y = y;
  }
  
  float x;
  float y;
}

// Version 3.2
// This example uses PharusClient class to access pharus data
// Pharus data is encapsulated into Player objects
// PharusClient provides an event callback mechanism whenever a player is been updated




PharusClient pc;
float stepDistance = 3; // distance between player steps

float lastTime = 0;
float delta = 0;
float timeInMs = 12; // small delay to let the sound play



 public void initPlayerTracking()
{
  pc = new PharusClient(this, wallHeight);
  // age is measured in update cycles, with 25 fps this is 2 seconds
  pc.setMaxAge(50);
  // max distance allowed when jumping between last known position and potential landing position, unit is in pixels relative to window width
  pc.setjumpDistanceMaxTolerance(0.05f);  
}

 public void drawPlayerTracking()
{
  // reference for hashmap: https://processing.org/reference/HashMap.html
  for (HashMap.Entry<Long, Player> playersEntry : pc.players.entrySet()) 
  {
    Player p = playersEntry.getValue();

    // render path of each track
    if (ShowPath)
    {
      if (p.getNumPathPoints() > 1)
      {
        stroke(70, 100, 150, 25.0f);        
        int numPoints = p.getNumPathPoints();
        int maxDrawnPoints = 3000;
        // show the motion path of each track on the floor    
        float startX = p.getPathPointX(numPoints - 1);
        float startY = p.getPathPointY(numPoints - 1);
        for (int pointID = numPoints - 2; pointID > max(0, numPoints - maxDrawnPoints); pointID--) 
        {
          float endX = p.getPathPointX(pointID);
          float endY = p.getPathPointY(pointID);
          line(startX, startY, endX, endY);
          startX = endX;
          startY = endY;
        }
      }
    }

    // render tracks = player
    if (ShowTrack)
    {
      // show each track with the corresponding  id number
      noStroke();
      if (p.isJumping())
      {
        fill(192, 0, 0);
      }
      else
      {
        fill(192, 192, 192);
      }
      ellipse(p.x, p.y, cursor_size, cursor_size);
      fill(0);
      text(p.id /*+ "/" + p.tuioId*/, p.x, p.y);
    }

    // render feet for each track
    if (ShowFeet)
    {
      // show the feet of each track
      stroke(70, 100, 150, 200);
      noFill();
      // paint all the feet that we can find for one character
      for (Foot f : p.feet)
      {
        ellipse(f.x, f.y, cursor_size / 3, cursor_size / 3);
      }
    }
  }
}

 public void pharusPlayerAdded(Player player)
{
  println("Player " + player.id + " added");
  
  // TODO do something here if needed
}

 public void pharusPlayerRemoved(Player player)
{
  println("Player " + player.id + " removed");
  
  // TODO do something here if needed  
}


PImage img;

// added for liminal storm
// takes path to image as an argument for drawing footprints
 public void drawFootprints(PImage img, PImage singlePrint) 
{
  
  int maxPoints = 30; //TODO adapt dynamically to number of players
  
  // reference for hashmap: https://processing.org/reference/HashMap.html
  for (HashMap.Entry<Long, Player> playersEntry : pc.players.entrySet()) 
  { 
    Player p = playersEntry.getValue();
    
      // show the feet of each track
        if (p.getNumPathPoints() > 1) {
          int numPoints = p.getNumPathPoints();
           
          float startX = p.getPathPointX(numPoints - 1);
          float startY = p.getPathPointY(numPoints - 1);
          
          /*file.play();
          file.stop();
          file.play();
          file.stop();*/
          for (int pointID = numPoints - 2; pointID > max(0, numPoints - maxPoints); pointID--) 
          {
            float endX = p.getPathPointX(pointID);
            float endY = p.getPathPointY(pointID);
            if(dist(startX,startY,endX,endY)>stepDistance){
              for (Foot f : p.feet) {
                translate(endX,endY);
                float a = atan2(endY-startY,endX-startX) + radians(90);
                rotate(a);
                //file.play();
                //file.stop();
                //image(img, f.x, f.y); // TODO: load individual footsteps image
                //rect(f.x, f.y, cursor_size / 3, cursor_size / 3);
                image(img, startX, startY); // both footprints
            }
            startX = endX;
            startY = endY;
          }
          
        
        }
      }
  }
}



 public void drawPath(PImage image){
  // defines the number of images drawn, when the limit is reached the oldest ones are "deleted"
  int maxPoints = 100; // change accordingly
  //imageMode(CENTER);
  
  for (HashMap.Entry<Long, Player> playersEntry : pc.players.entrySet()) 
  {
    Player p = playersEntry.getValue();
    delta = millis()- lastTime;
    // render path of each track
    
    if (p.getNumPathPoints() > 1)
      {
        stroke(70, 100, 150, 25.0f);        
        int numPoints = p.getNumPathPoints();
        
        // show the motion path of each track on the floor    
        float startX = p.getPathPointX(numPoints - 1);
        float startY = p.getPathPointY(numPoints - 1);
         
        file.stop();
       
        for (int pointID = numPoints - 2; pointID > max(0, numPoints - maxPoints); pointID--) 
        {
            float endX = p.getPathPointX(pointID);
            float endY = p.getPathPointY(pointID);
          if(dist(startX,startY,endX,endY)>stepDistance){
        
           
            if(delta == timeInMs){
              file.loop(); // Loops over audio file
              break;
            }
           
            float a = atan2(endY-startY,endX-startX); //+ radians(90);
            image(image, startX, startY);
           // translate(endX,endY); // TRANSLATION ISSUE
             //rotate(a);
            //image(image, startX, startY);
            //image(image, startX, startY);
            //file.stop();
            //print("a:" + a + " ");
            
            // play snow crunch sound here
             //line(startX, startY, endX, endY);
          }
          startX = endX;
          startY = endY;
          
          
          //fill(0);
         // file.play();
        
          
        }
      }
      lastTime = millis();
   }
   
  
}

int diameterx =  PApplet.parseInt(random(15,25));

 public void drawSpringPath(PImage image){
  // defines the number of images drawn, when the limit is reached the oldest ones are "deleted"
  int maxPoints = 100; // change accordingly
  
  for (HashMap.Entry<Long, Player> playersEntry : pc.players.entrySet()) 
  {
    Player p = playersEntry.getValue();
    delta = millis()- lastTime;
    // render path of each track
    
    if (p.getNumPathPoints() > 1)
      {
        stroke(70, 100, 150, 25.0f);        
        int numPoints = p.getNumPathPoints();
        
        // show the motion path of each track on the floor    
        float startX = p.getPathPointX(numPoints - 1);
        float startY = p.getPathPointY(numPoints - 1);
         
        //file.stop();
        
       
        for (int pointID = numPoints - 2; pointID > max(0, numPoints - maxPoints); pointID--) 
        {
            float endX = p.getPathPointX(pointID);
            float endY = p.getPathPointY(pointID);
          if(dist(startX,startY,endX,endY)>stepDistance){
            int index = PApplet.parseInt(random(0,flowers.length));
            if(delta == timeInMs){
             // file.loop(); // Loops over audio file
              break;
            }
           
              
              //scale(random(0.2,0.8));
            
              image(image,startX,startY, diameterx, diameterx);      
            
            
                     
          }
            startX = endX;
            startY = endY;
        }
      }
      lastTime = millis();
   }
   
  
}





 public void drawRainPath(PImage image){

  // defines the number of images drawn, when the limit is reached the oldest ones are "deleted"
  int maxPoints = 100; // change accordingly
  //imageMode(CENTER);
  
  for (HashMap.Entry<Long, Player> playersEntry : pc.players.entrySet()) 
  {
    Player p = playersEntry.getValue();
    delta = millis()- lastTime;
    // render path of each track
    
    if (p.getNumPathPoints() > 1)
      {
        stroke(70, 100, 150, 25.0f);        
        int numPoints = p.getNumPathPoints();
        
        // show the motion path of each track on the floor    
        float startX = p.getPathPointX(numPoints - 1);
        float startY = p.getPathPointY(numPoints - 1);
         
        file.stop();
       
        for (int pointID = numPoints - 2; pointID > max(0, numPoints - maxPoints); pointID--) 
        {
            float endX = p.getPathPointX(pointID);
            float endY = p.getPathPointY(pointID);
          if(dist(startX,startY,endX,endY)>stepDistance){
        
           
            if(delta == timeInMs){
              file.loop(); // Loops over audio file
              break;
            }
           
            float a = atan2(endY-startY,endX-startX); //+ radians(90);
            image(image, startX, startY);
           // translate(endX,endY); // TRANSLATION ISSUE
             //rotate(a);
            //image(image, startX, startY);
            //image(image, startX, startY);
            //file.stop();
            //print("a:" + a + " ");
            
            // play snow crunch sound here
             //line(startX, startY, endX, endY);
          }
          startX = endX;
          startY = endY;
          
          
          //fill(0);
         // file.play();
        
          
        }
      }
      lastTime = millis();
   }
  
}

// winter path

 public void drawWinterPath(PImage image){
  // defines the number of images drawn, when the limit is reached the oldest ones are "deleted"
  int maxPoints = 100; // change accordingly
  //imageMode(CENTER);
  
  for (HashMap.Entry<Long, Player> playersEntry : pc.players.entrySet()) 
  {
    Player p = playersEntry.getValue();
    delta = millis()- lastTime;
    // render path of each track
    
    if (p.getNumPathPoints() > 1)
      {
        stroke(70, 100, 150, 25.0f);        
        int numPoints = p.getNumPathPoints();
        
        // show the motion path of each track on the floor    
        float startX = p.getPathPointX(numPoints - 1);
        float startY = p.getPathPointY(numPoints - 1);
         
        winter.stop();
       
        for (int pointID = numPoints - 2; pointID > max(0, numPoints - maxPoints); pointID--) 
        {
            float endX = p.getPathPointX(pointID);
            float endY = p.getPathPointY(pointID);
          if(dist(startX,startY,endX,endY)>stepDistance){
        
           
            if(delta == timeInMs){
              //winter.loop(); // Loops over audio file
            // print("delta: " + delta);
              break;
            }
           
            float a = atan2(endY-startY,endX-startX); //+ radians(90);
            //scale(0.02);
           // image(image, startX, startY);
            //translate(endX,endY); // TRANSLATION ISSUE
            //rotate(a);
            //scale(0.02);
            image(image, startX, startY);
            //image(image, startX, startY);
            //image(image, startX, startY);
            //file.stop();
            //print("a:" + a + " ");
            
            // play snow crunch sound here
             //line(startX, startY, endX, endY);
          }
          startX = endX;
          startY = endY;
          
          
          //fill(0);
         // file.play();
        
          
        }
      }
      lastTime = millis();
   }
   
  
}

class BaseState {
  
  BaseState() {
  }
  
  BaseState(StateMgr _stateMgr, int _duration) {
    stateMgr = _stateMgr;
    duration = _duration;
  }

  
   public void setup() {
  }
  
   public void draw() {
  }
  
   public int getNextStateID() {
    return stateID;
  }
 
   public void setID(int _stateID) {
    stateID = _stateID;
  }

   public int getID() {
    return stateID;
  }
  
   public void setStateMgr(StateMgr _stateMgr) {
    stateMgr = _stateMgr;
  }

  int stateID; 
  int duration;
  
  StateMgr stateMgr;
}
class End extends BaseState {
  
  End() {
    super();
  }
  
  End(StateMgr _stateMgr, int _duration) {
    super(_stateMgr, _duration); 
  }
  
   public void draw() {
    fill(200, 162, 200);
    rect(0, 0, width, height);
  }  
  
}


float yIncrement = 0.02f;
float zIncrement = 0.00025f;
float scl = 20;
float zoff = 0;

int cols = floor(windowWidth / scl) + 1;
int rowsWall = round(wallHeight/3 / scl) + 1;
int rowsFloor = round(wallHeight/scl) + 1;

// array with file paths
String[] audioFiles = {s1, s2, s3, s4, s5};

int interval;

class Grass extends BaseState {
  
  Grass() {
    super();
  }
  
  Grass(StateMgr _stateMgr, int _duration) {
    super(_stateMgr, _duration); 
    interval = duration / audioFiles.length;
  }
  
   public void draw() {
    clear();
    background(73, 106, 45);

    setGradient(0, 0, width, height/2, color(177, 213, 174), color(73, 106, 45));
    
    grassFloor();
    grassWall();
    
    text((int)frameRate + " FPS", width / 2, 100);


    //if(osCompatible) drawSpringPath(fl1);

  } 
  
  
  
   public void grassFloor(){
    float yoff = 0;
    for (int y = 0; y < rowsFloor; y++){
      float xoff = 0;
      for (int x = 0; x < cols; x++){
        float angle = noise(xoff, yoff, zoff) * TWO_PI;
        xoff += yIncrement;
        PVector vector = PVector.fromAngle(angle);
        vector.setMag(1);
  
        fill(255);
        noStroke();
        push();
          translate(x * scl, y * scl + wallHeight);
          rotate(vector.heading());
          quad(0,0,0,1,scl+10,scl+10,1,0);
        pop();
      }
      yoff += yIncrement;
      zoff += 0.00025f;
    }
  }
  
   public void grassWall(){
    float yoff = 0;
    for (int y = 0; y < rowsWall; y++){
      float xoff = 0;
      for (int x = 0; x < cols; x++){
        float angle = noise(xoff, yoff, zoff) * -PI;
        xoff += yIncrement;
        PVector vector = PVector.fromAngle(angle);
        vector.setMag(1);
  
        fill(255);
        noStroke();
        push();
          translate(x * scl, y * scl/1.5f + 2.3f * wallThird);
          rotate(vector.heading());
          quad(0,0,0,1,scl+10,scl+10,1,0);
        pop();
      }
      yoff += yIncrement;
      zoff += 0.00025f;
    }
  }
  
   public void setGradient(int x, int y, float w, float h, int c1, int c2) {  
    for (int i = y; i <= y+h; i++) {
      float inter = map(i, y, y+h, 0, 1);
      int c = lerpColor(c1, c2, inter);
      strokeWeight(2);
      stroke(c);
      line(x, i, x+w, i);
    }
  }
  
  
  
}
//Foliage Variables
int amountFol = 1000;
float [] xPosFol = new float[amountFol];
float [] yPosFol = new float[amountFol];
float [] dFol = new float[amountFol]; //Size
int [] rotFol = new int[amountFol]; //Rotation
int minFSizeFol = 2;
int maxFSizeFol = 10;

//Leaves Variables
int amountLeaves=500; // number of snowflakes
float [] xPosLeaves = new float[amountLeaves];
float [] yPosLeaves = new float[amountLeaves];
int [] d = new int[amountLeaves]; //Size
int [] speedLeaves = new int[amountLeaves]; //Speed
int [] rot = new int[amountLeaves]; //Rotation
int minFSizeLeaves = 2;
int maxFSizeLeaves = 10;


class Leaves extends BaseState {
  
  Leaves() {
    super();
  }
  
  Leaves(StateMgr _stateMgr, int _duration) {
    super(_stateMgr, _duration); 
    
    //Fill Leaves Arrays
    for(int i = 0; i < amountLeaves; i++) { //Creates four arrays with a box for each value
      rot[i] = round(random(0, 360));
      xPosLeaves[i] = random(0, width);
      yPosLeaves[i] = random(0, wallHeight);
      d[i] = round(random(minFSizeLeaves, maxFSizeLeaves));
      speedLeaves[i] = round(random(0, 1));
    }
    
    //Fill Foliage Arrays
    for (int i = 0; i < amountFol; i++){
      xPosFol[i] = random(0, width);
      yPosFol[i] = random(0, wallHeight);
      dFol[i] = round(random(minFSizeFol, maxFSizeFol));
      rotFol[i] = round(random(0, 360));
    }
  }
  
   public void draw() {
    clear();
    background(209, 133, 46);
    
    setGradient(0, 0, width, wallHeight, color(223, 193, 158), color(209, 133, 46));
    text((int)frameRate + " FPS", width / 2, 10);
  
    //FALLING LEAVES
    for(int i = 0; i < xPosLeaves.length; i++) {
  
      noFill();
      stroke(255);
      strokeWeight(1);
      rotate(rot[i]);
      quad(xPosLeaves[i], yPosLeaves[i], xPosLeaves[i]+d[i], yPosLeaves[i]+(d[i]*2), xPosLeaves[i], yPosLeaves[i]+(d[i]*3), xPosLeaves[i]-d[i], yPosLeaves[i]+(d[i]*2));
     
      //Creates movement on the x-axis
      if(speedLeaves[i] == 0) {
        xPosLeaves[i] += map(rot[i], minFSizeLeaves, maxFSizeLeaves, .1f, .5f); 
      } else {
        xPosLeaves[i] -= map(rot[i], minFSizeLeaves, maxFSizeLeaves, .1f, .5f);
      }
     
      //Keep adding size of flake to speed to create movement in the y-axis
      yPosLeaves[i] += (d[i] + speedLeaves[i])/3;  
      
  
     //Creates endless loop of flakes
      if(xPosLeaves[i] > width + rot[i] || xPos[i] < -rot[i] || yPosLeaves[i] > wallHeight + rot[i]) {
        xPos[i] = random(0, width);
        yPosLeaves[i] = -rot[i];
      }  
    }
    
    //FOLIAGE
    for(int i = 0; i < xPosFol.length; i++) {
      stroke(255);
      noFill();
      rotate(rotFol[i]);
      //Scale leaf
      int m = millis();
      if (m < 1500){
        if(dFol[i]>5){
           dFol[i] -= .2f;
        }
      }
      quad(xPosFol[i], yPosFol[i], xPosFol[i]+dFol[i], yPosFol[i]+(dFol[i]*2), xPosFol[i], yPosFol[i]+(dFol[i]*3), xPosFol[i]-dFol[i], yPosFol[i]+(dFol[i]*2));
    }   
    
    
    //I guess thats Leaves?
    //if(osCompatible) drawPath(img2);

  }
}


 public void setGradient(int x, int y, float w, float h, int c1, int c2) {  
  for (int i = y; i <= y+h; i++) {
    float inter = map(i, y, y+h, 0, 1);
    int c = lerpColor(c1, c2, inter);
    strokeWeight(2);
    stroke(c);
    line(x, i, x+w, i);
  }
}

int amountIntervals = 4; //minimum 3

//Drops Variables
int amountDrops=750; // number of drops
int maxDrops =1000;
int minDrops=100;
Drop[] drops=new Drop[maxDrops];

//Puddles Variables
int amountPuddles=150; // number of drops
int maxPuddles =300;
int minPuddles=10;
Puddle[] puddles=new Puddle[maxPuddles];

class Rain extends BaseState{
  
  Rain() {
    super();
  }
  
  //Constructor
  Rain(StateMgr _stateMgr, int _duration) {
    super(_stateMgr, _duration); 
    duration = _duration;
      
    //Fill Drop Array
    for (int i = 0; i < maxDrops; i++){
      //drops[i] = new Drop(int(random(width)),-int(random(wallHeight)),(int)map((hFloor+int(random(wallThird))),wallHeight*.75,wallHeight,0,wallHeight),1280); 
      drops[i] = new Drop(PApplet.parseInt(random(width)),-PApplet.parseInt(random(wallHeight)),(int)random(wallHeight), 1280/2); 
    }
  
    //Fill Puddle Array
    for (int i = 0; i < maxPuddles; i++){
      puddles[i] = new Puddle(PApplet.parseInt(random(width)),-PApplet.parseInt(random(wallHeight,height)),PApplet.parseInt(random(wallHeight+50,height)),1280); 
    }
  }
  
   public void draw() {
    clear();
    background(0, 65, 75);
    setGradient(0, 0, width, wallHeight, color(122, 172, 172), color(0, 65, 75));
  
    text((int)frameRate + " FPS", width / 2, 10);

  
  
    //Draw floor Snow with increasing time by mapping it to the duration
    int timeNow = super.stateMgr.getTimeInState();
    int start = super.stateMgr.stateStamp;
    int end = start + duration;
    int drawAmountDrops, drawAmountPuddles;
    
    text(PApplet.parseFloat(timeNow)/1000/60 + " seconds", width / 2, 20);
    
    if(timeNow < duration/amountIntervals){
      drawAmountDrops = (int) map(timeNow, start, end, 0, amountDrops);  
      drawAmountPuddles = (int) map(timeNow, start, end, 0, amountPuddles);      
    } else if (timeNow > (duration/amountIntervals) * amountIntervals-2){
      drawAmountDrops = (int) map(timeNow, start, end, amountDrops/2, 0);  
      drawAmountPuddles = (int) map(timeNow, start, end, amountPuddles/2, 0);  
    } else {
      drawAmountDrops = amountDrops;  
      drawAmountPuddles = amountPuddles;
    }
    
      
    for (int i = 0; i<drawAmountDrops;i++){
      drops[i].fall();
    }
    
    for (int i=0;i<drawAmountPuddles;i++){
      puddles[i].grow();
    }
    
    //if(osCompatible) drawRainPath(img3);
  }
  
   public void setGradient(int x, int y, float w, float h, int c1, int c2) {  
    for (int i = y; i <= y+h; i++) {
      float inter = map(i, y, y+h, 0, 1);
      int c = lerpColor(c1, c2, inter);
      strokeWeight(2);
      stroke(c);
      line(x, i, x+w, i);
    }
  }
}



//CLASS DROP
class Drop{
  int x,y,d,z,onde,d1,oldY;
  float acc;
  boolean s;

  Drop(int x,int y, int z, int d){
    this.x=x;
    this.y=y;
    this.d=d;
    this.z=z;
    onde=0;
    d1=d;
    acc=0;
    oldY=y;
  }

   public void fall(){ //Rain fall
    if(y>0)acc+=0.2f;
    stroke(200,200,200,map(z,0,height,0,255));
    strokeWeight(2);
    if (y<z){
      y=PApplet.parseInt(y+4+acc);
      line(x,oldY,x,y);
      oldY=y;
    }
    else{ //Floor extension
      noFill();
      stroke(175,175,175,255-map(onde,0,d,0,255));
      strokeWeight(map(onde,0,d,0,4));
      d=d1+(y-wallHeight)*4;
      ellipse(x,y,onde/10,onde/40);
      onde=onde+7;
      if(onde>d){
        onde=0;
        acc=0;
        x=PApplet.parseInt(random(width));
        y=-PApplet.parseInt(random(wallHeight*2));
        oldY=y;
        d=d1;
      }
    }
  }
}

// CLASS PUDDLE
class Puddle{
  int x,y,d,z,rain,d1;
  float acc;
  boolean s;

  Puddle(int x,int y, int z, int d){
    this.x=x;
    this.y=y;
    this.d=d;
    this.z=z;
    rain=0;
    d1=d;
    acc=0;
  }

   public void grow(){
    if(y>0)acc+=0.2f;
    strokeWeight(0);
    if (y<z){
      y=PApplet.parseInt(y+14);
      line(x,y,x,y);
    }
    else{
      noFill();
      stroke(255);
      strokeWeight(1);
      d=d1+(y-height);
      ellipse(x,y,rain/10,rain/10);
      rain=rain+7;
      if(rain>d){
        rain=0;
        acc=0;
        x=PApplet.parseInt(random(width));
        y=-PApplet.parseInt(random(height*2));
        d=d1;
      }
    }
  }
}
//Snow Variables
int amountSnow=1000; // number of snowflakes
float [] xPos = new float[amountSnow];
float [] yPos = new float[amountSnow];
int [] speed = new int[amountSnow]; //Speed
int [] fSize = new int[amountSnow]; //Flake Size
int minFSize = 3;
int maxFSize = 6;

//Floor flakes Variables
int amountFlakes=10000; // number of flakes
int maxFlakes =30000;
int minFlakes=15000;
int[][] snowFloor;

class Snow extends BaseState {
  
  Snow() {
    super();
  }
  
  Snow(StateMgr _stateMgr, int _duration) {
    super(_stateMgr, _duration); 
    
    //Fill Snow Arrays
    for(int i = 0; i < amountSnow; i++) { //Creates four arrays with a box for each value
      fSize[i] = round(random(minFSize, maxFSize));
      xPos[i] = random(0, width);
      yPos[i] = random(0, wallHeight);
      speed[i] = round(random(0, 1));
    }
  
    snowFloor = generateSnowFloor(amountFlakes);
  }
  
   public void draw() {    
    clear();
    background(118, 144, 172);
    
    setGradient(0, 0, width, wallHeight, color(223, 239, 246), color(118, 144, 172));
   
    text((int)frameRate + " FPS", width / 2, 10);
  
    //FALLING SNOW
    for(int i = 0; i < xPos.length; i++) {
  
      fill(255,255,255);
      noStroke();
      ellipse(xPos[i], yPos[i], fSize[i], fSize[i]); //Create flake with values from the four arrays
     
      //Creates movement on the x-axis
      if(speed[i] == 0) {
        xPos[i] += map(fSize[i], minFSize, maxFSize, .1f, .5f); 
      } else {
        xPos[i] -= map(fSize[i], minFSize, maxFSize, .1f, .5f);
      }
     
      //Keep adding size of flae to speed to create movement in the y-axis
      yPos[i] += fSize[i]/5 + speed[i]; 
      
  
     //Creates endless loop of flakes
      if(xPos[i] > width + fSize[i] || xPos[i] < -fSize[i] || yPos[i] > wallHeight + fSize[i]) {
        xPos[i] = random(0, width);
        yPos[i] = -fSize[i];
      }  
    } 
    
    int start = super.stateMgr.stateStamp;
    int timeNow = millis();//super.stateMgr.getTimeInState();
    int end = start + duration;
    int drawAmount;
    
    //Draw floor Snow with increasing time by mapping it to the duration
    if(timeNow < duration/2+start + 100){
      drawAmount = (int) map(timeNow, start, end - duration/2, 0, amountFlakes); 
    } else {
      drawAmount = amountFlakes;
      int alpha = (int)map(timeNow,start + PApplet.parseInt(duration/2), end, 0,255);
      fill(255,alpha);
      rect(0, wallHeight, width, windowHeight);
    } 
    
    if(drawAmount > amountFlakes) drawAmount = amountFlakes-1;
    
    for (int i = 0; i<drawAmount;i++){
        noStroke();
        fill(255);
        ellipse(snowFloor[i][0], snowFloor[i][1],5,5);
    }
    
    //if(osCompatible) drawWinterPath(w1);
  } 
  
   public void setGradient(int x, int y, float w, float h, int c1, int c2) {  
    for (int i = y; i <= y+h; i++) {
      float inter = map(i, y, y+h, 0, 1);
      int c = lerpColor(c1, c2, inter);
      strokeWeight(2);
      stroke(c);
      line(x, i, x+w, i);
    }
  }
  
  public int[][] generateSnowFloor(int n) {
    Random random = new Random();
    int[][] coordinates = new int[n][2];
    for (int i = 0; i < n; i++) {
        int x = random.nextInt(width);
        int y = random.nextInt(wallHeight,height);
        coordinates[i] = new int[] {x, y};
    }
    return coordinates;
  }
  
}
class Storm extends BaseState {
  
  Storm() {
    super();
  }
  
  Storm(StateMgr _stateMgr, int _duration) {
    super(_stateMgr, _duration); 
  }
  
   public void draw() {
    fill(0, 0, 0);
    rect(0, 0, width, height);
  }  
  
}






int amountOfStates = 4; //without grass and end

public class TimeSplit {
    public int[] splitInterval() {
        Random rng = new Random();
 
        int numSplits = rng.nextInt(3) + 3;
        int[] splitDurations = new int[numSplits];
        //int duration = rng.nextInt(6) * 60000 + (5 * 60000);
        int duration = rng.nextInt(1 * 60000) + (1 * 60000);
        
        println("Seconds: ", duration/1000);

        int sum = 0;
  
        for (int i = 0; i < numSplits; i++) {
            int num;
            if (i == numSplits - 1) {
                // Generate the last number so that the sum adds up to k
                num = duration - sum;
            } else {
                num = rng.nextInt(duration - sum) + 1; // Generate a random number between 1 and k - sum (inclusive)
                sum += num;
            }
            splitDurations[i] = (int) num;
        }

        return splitDurations;
    }

    //Numbers from 1 to array length
    public int[] assignNumbersOrder(int[] array) {
        int n = array.length -1; // Number of elements

        // Create an array of integers from 1 to n
        int[] numbers = new int[n];
        for (int i = 0; i < n; i++) {
            numbers[i] = i + 1;
        }


        // Shuffle the array
        return shuffleArray(numbers);
    }
    
    //Numbers n out of 5
    public int[] assignNumbers(int[] array) {
      int n = amountOfStates; // Number of elements
      List<Integer> numbers = new ArrayList<>();
      
      for (int i = 1; i <= n; i++) {
        numbers.add(i);
      }
      
      // Select k numbers at random
      Random random = new Random();
      int amountOfNumbers = array.length - 1;
      int[] selection = new int[amountOfNumbers];
      
      for (int i = 0; i < array.length - 1; i++) {
        int j = random.nextInt(numbers.size());
        selection[i] = numbers.get(j);
        numbers.remove(j);
        n--;
      }
      
      return selection;
      
    }

    
    public int[] shuffleArray(int[] array) {
        Random random = new Random();
        
        for (int i = array.length - 1; i > 0; i--) {
          int j = random.nextInt(i + 1);
          int temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
        
        return array;
    }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
